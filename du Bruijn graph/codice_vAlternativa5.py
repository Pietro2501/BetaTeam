from BioSequence import tools_Bio as t
import time

from trimming import dinamic_trimming


class Node:
    """
    Represents a node with a label and a counter.

    This class is used to manage individual nodes, where each node has
    a label (string) and a counter that can be incremented. The nodes
    can also be compared with each other based on their labels.

    :param label: The label of the node.
    :type label: str
    :param contatore: The counter associated with the node.
    :type contatore: int
    """

    def __init__(self, lab):
        self.label = lab
        self.contatore = 0

    def __eq__(self, other):
        return self.label == other.label

    def incrementa_contatore(self):
        self.contatore += 1

class Edge:
    """
    Represents an edge in a graph structure.

    This class is used to define edges in a k-1 mer based de Bruijn graph, where each
    edge is identified by a unique label derived from a tuple of two k-1 mers.
    The concatenation of the left k-1 mer and the last character of the right
    k-1 mer forms the label of the edge. This class provides functionality for
    creating the edge and equality comparison.

    :param label: The label of the edge, generated by concatenating the left
        k-1 mer in the tuple with the last character of the right k-1 mer.
    :type label: str
    """

    def __init__(self, km1mer_tuple):
        self.label = km1mer_tuple[0] + km1mer_tuple[1][-1:]

    def __eq__(self, other):
        return self.label == other.label

def parse_fastq(file_obj: str, offset=33) -> dict:
    """
    Parses a FASTQ file and returns a dictionary representation of the sequences,
    quality scores and ASCII quality scores. The function processes the input file
    line by line, ensuring the structural integrity for each FASTQ record, including
    checking coherence of headers and applicable offset values for quality score
    conversion.

    :param file_obj: A file object containing the FASTQ data to be parsed.
    :type file_obj: str
    :param offset: Offset value used for ASCII quality score conversion.
                   Should only be either 33 or 64.
    :type offset: int
    :return: A dictionary where the keys are sequence identifiers (headers starting
             with '@') and values are sub-dictionaries containing sequence strings,
             ASCII quality scores, and numeric quality scores. Returns None if the file
             is found to be corrupted or improperly formatted.
    :rtype: dict or None
    """
    with open(file_obj, "r") as file_obj:
        def check_offset(offset: int) -> bool:
            res = False
            if type(offset) == int and offset in [33, 64]:
                res = True
            return res

        def check_coherence(acc: str, plus: str) -> bool:
            """
            Validates the coherence of a FASTQ record by checking the format of
            the accession line and the "+" line.

            The function ensures that the accession line starts with "@" and
            the "+" line starts with "+", which is required for the correct
            format of a FASTQ record.

            :param acc: The accession line from the FASTQ record.
            :type acc: str
            :param plus: The "+" line from the FASTQ record.
            :type plus: str
            :return: True if both the accession and the "+" lines are in the
                correct format, otherwise False.
            :rtype: bool
            """
            res = False
            if acc.startswith("@") and plus.startswith("+"):
                res = True
            return res

        if check_offset(offset):
            fastq_dict = {}
            line = file_obj.readline()
            while line:
                acc = line.strip()
                fastq_dict.setdefault(acc, {})
                seq, plus, qual = file_obj.readline().strip(), file_obj.readline().strip(), file_obj.readline().strip()
                if not check_coherence(acc, plus):
                    print("Il file è corrotto!!!")
                    fastq_dict = None
                    break
                if seq and qual:
                    fastq_dict[acc]["seq"] = seq
                    fastq_dict[acc]["ASCII_qual"] = qual
                    fastq_dict[acc]["qual"] = [ord(q) - offset for q in fastq_dict[acc]["ASCII_qual"]]
                else:
                    print("Il file è corrotto!!!")
                    fastq_dict = None
                    break
                line = file_obj.readline()
            return fastq_dict
        elif not check_offset(offset):
            print(f"l'offset indicato non è numerico o è un valore differente da 33 o 64!!!")


def exp_err(qual, is_ascii=False):
    """
    Calculate the sum of expected error probabilities from quality scores.

    This function computes the expected error based on provided quality scores.
    The quality scores can either be in ASCII-encoded form (default) or as raw
    numerical values. The quality scores are converted to probabilities using
    Q = -10 * log10(P), where P is the probability of error corresponding to a
    given quality score.

    :param qual: The quality scores. If `is_ascii` is True, they are
        expected to be ASCII-encoded characters. Otherwise, they should
        be numerical values.
    :type qual: list or str
    :param is_ascii: Whether the input `qual` is ASCII-encoded. Defaults
        to False.
    :type is_ascii: bool
    :return: The sum of expected error probabilities.
    :rtype: float
    """
    if is_ascii:
        ee = sum(map(lambda q: 10 ** (q / -10), map(lambda x: ord(x) - 33, qual)))
    else:
        ee = sum(map(lambda q: 10 ** (q / -10), qual))
    return ee


def dinamic_trimming(dict_fastq: dict, threshold=25, window=15):
    """
    Performs dynamic trimming of sequencing reads based on quality scores.

    This function takes a dictionary containing sequencing reads and their quality
    information. It performs a dynamic trimming process by evaluating the average
    quality score of a sliding window. When the average quality falls below a given
    threshold, the function trims the read from the point where quality criteria
    are no longer met.

    :param dict_fastq: Dictionary containing sequencing reads and their associated
        quality scores.
    :param threshold: Integer threshold below which the average quality score is
        considered too low. Default is 25.
    :param window: Integer size of the sliding window used to compute the average
        quality score. Default is 15.
    :return: The updated dictionary after processing, where reads not meeting
        quality criteria are trimmed.
    :rtype: dict
    """
    for key in dict_fastq.keys():
        quality = dict_fastq[key]["qual"]
        list_mean = quality[:window]
        if sum(list_mean)/len(list_mean) < threshold:
            for value in range(len(list_mean), len(quality)):
                if (sum(list_mean)+quality[value])/(len(list_mean)+1) < threshold:
                    list_mean.append(quality[value])
                else:
                    break
            dict_fastq[key].update({"seq": dict_fastq[key]["seq"][len(list_mean):]})
            dict_fastq[key].update({"qual": dict_fastq[key]["qual"][len(list_mean):]})
            dict_fastq[key].update({"ASCII_qual": dict_fastq[key]["ASCII_qual"][len(list_mean):]})
    return dict_fastq

def dict_filter(_dict_fastq: dict, k: int):
    """
    Filters a given dictionary containing FASTQ data by removing entries with sequenced
    reads that exceed a specified error threshold.

    The function iterates through the dictionary, calculates an expected error value
    for each entry's quality scores, and deletes entries where the error value
    exceeds the given threshold.

    :param _dict_fastq: Dictionary containing FASTQ data where the key is typically
        the identifier of a read and the value is a dictionary containing read
        attributes.
    :type _dict_fastq: dict
    :param k: The error threshold. Entries in `_dict_fastq` with expected error
        values greater than this threshold will be removed.
    :type k: int
    :return: A dictionary with filtered FASTQ entries where all remaining entries meet
        the error threshold defined by `k`.
    :rtype: dict
    """
    list_keys = list(_dict_fastq.keys())
    for key in list_keys:
        expect_err = exp_err(_dict_fastq[key]["qual"])
        if expect_err > k:
            del _dict_fastq[key]
    return _dict_fastq

def rev_comp(seqlist: list):
    """
    Generate the reverse complement sequences for a given list of DNA sequences, append them to the
    original list, and return the combined list.

    :param seqlist: A list of DNA sequences for which reverse complements are to be calculated
    :type seqlist: list
    :return: A combined list of original sequences and their reverse complements
    :rtype: list
    """
    table= str.maketrans('ACTG','TGAC')
    total_list = [seq.translate(table)[::-1] for seq in seqlist] + seqlist
    return total_list


def construct_graph(reads: list, k: int):
    """
    Constructs a De Bruijn graph from a given list of DNA reads and k-mer length.

    The function builds a De Bruijn graph by analyzing k-mers in the reads. It
    creates nodes and edges based on overlapping k-mers, with edges connecting
    nodes derived from overlapping regions.

    :param reads: A list of DNA sequences (reads) from which the De Bruijn graph
        will be constructed.
    :type reads: list
    :param k: An integer representing the k-mer length to be used in constructing
        the graph.
    :type k: int

    :return: A tuple where the first element is a dictionary of edges
             and the second element is a dictionary of nodes.
    :rtype: tuple
    """
    edges = {}
    nodes = {}

    for read in reads:
        for i in range(len(read) - k + 1):
            # creazione e gestione degli archi
            edge_label = read[i:i + k - 1] + read[i + 1:i + k][-1]
            if edge_label not in edges:
                edges[edge_label] = Edge((read[i:i + k - 1], read[i + 1:i + k]))

            # gestione dei nodi con dizionari
            n1_label = read[i:i + k - 1]
            n2_label = read[i + 1:i + k]

            if n1_label not in nodes:
                nodes[n1_label] = Node(n1_label)
            else:
                nodes[n1_label].incrementa_contatore()

            if n2_label not in nodes:
                nodes[n2_label] = Node(n2_label)
            else:
                nodes[n2_label].incrementa_contatore()

    return edges, nodes

def output_contigs(graph: tuple):
    """
    Generate a contig from a given graph structure.

    This function processes a graph represented by its edges and nodes to construct
    a contig. It starts with the appropriate starting node, which is identified
    based on outgoing and incoming edges' existence, then iteratively follows the
    edges to build the contig sequence. The function raises an exception if the
    graph structure is invalid, such as missing a valid starting node or containing
    conflicting connections.

    :param graph: A tuple containing the graph representation in two components:
        - `edges`: A collection of edges objects, where each edge connects nodes.
        - `nodes`: A collection of node identifiers to their respective node objects.

    :return: A string representing the reconstructed contig, constructed from
        traversing the graph based on its edges and nodes.
    :rtype: str
    :raises ValueError: If the graph structure is invalid, such as if no starting
        node is found or valid traversal cannot be completed because of invalid edges
        or nodes.

    """
    edges, nodes = graph
    start = None
    for node in nodes.values():
        # trovo i possibili archi che partono dal nodo corrente
        outcoming_edges = [edge for edge in edges.values() if edge.label.startswith(node.label)]
        # trovo i possibili archi che arrivano nel nodo corrente
        incoming_edges = [edge for edge in edges.values() if edge.label.endswith(node.label)]

        # il nodo di partenza è quello che ha almeno un arco in uscita, ma nessun arco in ingresso
        if outcoming_edges and not incoming_edges:
            start = node
            break

    if start is None:
        raise ValueError("Nessun nodo di partenza trovato. Verifica la struttura del grafo.")

    contig = start.label
    current = start

    while True:
        # trovo gli archi che partono dal nodo corrente
        outcoming_edges = [edge for edge in edges.values() if edge.label.startswith(current.label)]

        if len(outcoming_edges) == 0:
            break  # se non ci sono più archi esce dal ciclo
        elif len(outcoming_edges) == 1:
            next_edge = outcoming_edges[0]
        else:  # se ci sono più archi, scelgo quello il cui nodo di arrivo abbia il contatore maggiore
            best_edge = None
            max_contatore = -1

            for edge in outcoming_edges:
                destination_label = edge.label[1:]
                # trovo il nodo di destinazione per l'arco sulla base della label identificata
                destination_node = None
                for node in nodes.values():
                    if node.label == destination_label:
                        destination_node = node
                        break
                if destination_node.contatore > max_contatore:
                    best_edge = edge
                    max_contatore = destination_node.contatore

            if best_edge is None:
                raise ValueError("Nessun arco valido trovato con un nodo di destinazione valido.")

            next_edge = best_edge

        del edges[next_edge.label]  # rimuovo l'arco dalla lista degli archi
        contig += next_edge.label[-1]  # aggiungo l'ultimo carattere del k-mer al contig

        destination_label = next_edge.label[1:]  # definisco il nodo successivo per ricostruire il contig
        current = None
        for node in nodes.values():
            if node.label == destination_label:
                current = node
                break

        if current is None:
            raise ValueError(f"Errore: il nodo successivo con label {destination_label} non è stato trovato nel grafo.")

    return contig

file_f= t.extract_info(r"PhoeVulATCC8482_R1.fq.gz")
dict_fastq_f= parse_fastq(file_f)
print (f"il file R1 contiene {len(dict_fastq_f)} sequenze")
dict_filtered_f = dinamic_trimming(dict_fastq_f)
dict_double_filtered_f = dict_filter(dict_filtered_f, 3)
seq_filtered_f = [dict_double_filtered_f[key]["seq"] for key in dict_double_filtered_f.keys() if len(dict_double_filtered_f[key]["seq"]) > 100]
print (f"dopo aver filtrato e trimmato sono rimaste {len(seq_filtered_f)} sequenze del file R1")

file_r= t.extract_info(r"PhoeVulATCC8482_R2.fq.gz")
dict_fastq_r= parse_fastq(file_r)
print (f"il file R2 contiene {len(dict_fastq_r)} sequenze")
dict_filtered_r = dinamic_trimming(dict_fastq_r)
dict_double_filtered_r = dict_filter(dict_filtered_r, 4)
seq_filtered_r = [dict_double_filtered_r[key]["seq"] for key in dict_double_filtered_r.keys() if len(dict_double_filtered_r[key]["seq"]) > 100]
print (f"dopo aver filtrato e trimmato sono rimaste {len(seq_filtered_r)} sequenze del file R2")

mucchio_selvaggio = seq_filtered_f + seq_filtered_r
delirio_totale = rev_comp(mucchio_selvaggio)
print(f"il grafo verrà costruito utilizzando {len(delirio_totale)} sequenze")
de_bruijn_graph = construct_graph(delirio_totale, 29)
final_contig = output_contigs(de_bruijn_graph)

print(f"percorrendo il grafo, il contig finale ha una lunghezza di {len(final_contig)}")