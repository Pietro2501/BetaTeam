from BioSequence import tools_Bio as t
import time

from trimming import dinamic_trimming


class Node:
    """
    Represents a node with a label and a counter.

    This class is used to manage individual nodes, where each node has
    a label (string) and a counter that can be incremented. The nodes
    can also be compared with each other based on their labels.

    :ivar label: The label of the node.
    :type label: str
    :ivar contatore: The counter associated with the node.
    :type contatore: int
    """

    def __init__(self, lab):
        self.label = lab
        self.contatore = 0

    def __eq__(self, other):
        return self.label == other.label

    def incrementa_contatore(self):
        self.contatore += 1

class Edge:
    """
    Represents an edge in a graph structure.

    This class is used to define edges in a k-1 mer based graph, where each
    edge is identified by a unique label derived from a tuple of two k-1 mers.
    The concatenation of the first k-1 mer and the last character of the second
    k-1 mer forms the label of the edge. This class provides functionality for
    creating the edge and equality comparison.

    :ivar label: The label of the edge, generated by concatenating the first
        k-1 mer in the tuple with the last character of the second k-1 mer.
    :type label: str
    """

    def __init__(self, km1mer_tuple):
        self.label = km1mer_tuple[0] + km1mer_tuple[1][-1:]

    def __eq__(self, other):
        return self.label == other.label

def parse_fastq(file_obj, offset=33) -> dict:
    """
    Parses a FASTQ file and returns a dictionary representation of the sequences,
    quality scores, and additional metadata. The function processes the input file
    line by line, ensuring the structural integrity for each FASTQ record, including
    checking coherence of headers and applicable offset values for quality score
    conversion.

    :param file_obj: A file object containing the FASTQ data to be parsed.
    :type file_obj: str
    :param offset: Offset value used for ASCII quality score conversion.
                   Should only be either 33 or 64.
    :type offset: int
    :return: A dictionary where the keys are sequence identifiers (headers starting
             with '@') and values are sub-dictionaries containing sequence strings,
             ASCII quality scores, and numeric quality scores. Returns None if the file
             is found to be corrupted or improperly formatted.
    :rtype: dict or None
    """
    with open(file_obj, "r") as file_obj:
        def check_offset(offset: int) -> bool:
            res = False
            if type(offset) == int and offset in [33, 64]:
                res = True
            return res

        def check_coherence(acc: str, plus: str) -> bool:
            """
            Validates the coherence of a FASTQ record by checking the format of
            the accession line and the "+" line.

            The function ensures that the accession line starts with "@" and
            the "+" line starts with "+", which is required for the correct
            format of a FASTQ record.

            :param acc: The accession line from the FASTQ record.
            :type acc: str
            :param plus: The "+" line from the FASTQ record.
            :type plus: str
            :return: True if both the accession and the "+" lines are in the
                correct format, otherwise False.
            :rtype: bool
            """
            res = False
            if acc.startswith("@") and plus.startswith("+"):
                res = True
            return res

        if check_offset(offset):
            fastq_dict = {}
            line = file_obj.readline()
            while line:
                acc = line.strip()
                fastq_dict.setdefault(acc, {})
                # qui andrebbe inserito un try/expcet per verificare che effettivamente tutte le linee siano lette
                seq, plus, qual = file_obj.readline().strip(), file_obj.readline().strip(), file_obj.readline().strip()
                if not check_coherence(acc, plus):
                    print("Il file è corrotto!!!")
                    fastq_dict = None
                    break
                if seq and qual:
                    fastq_dict[acc]["seq"] = seq
                    fastq_dict[acc]["ASCII_qual"] = qual
                    fastq_dict[acc]["qual"] = [ord(q) - offset for q in fastq_dict[acc]["ASCII_qual"]]
                    # fastq_dict[acc]["Pe"] = [10 ** (q / -10) for q in fastq_dict[acc]["qual"]]
                else:
                    print("Il file è corrotto!!!")
                    fastq_dict = None
                    break
                line = file_obj.readline()
            return fastq_dict
        elif not check_offset(offset):
            print(f"l'offset indicato non è numerico o è un valore differente da 33 o 64!!!")


def exp_err(qual, is_ascii=False):
    """
    Calculate the sum of expected error probabilities from quality scores.

    This function computes the expected error based on provided quality scores.
    The quality scores can either be in ASCII-encoded form (default) or as raw
    numerical values. The quality scores are converted to probabilities using
    Q = -10 * log10(P), where P is the probability of error corresponding to a
    given quality score.

    :param qual: The quality scores. If `is_ascii` is True, they are
        expected to be ASCII-encoded characters. Otherwise, they should
        be numerical values.
    :type qual: list or str
    :param is_ascii: Whether the input `qual` is ASCII-encoded. Defaults
        to False.
    :type is_ascii: bool
    :return: The sum of expected error probabilities.
    :rtype: float
    """
    if is_ascii:
        ee = sum(map(lambda q: 10 ** (q / -10), map(lambda x: ord(x) - 33, qual)))
    else:
        ee = sum(map(lambda q: 10 ** (q / -10), qual))
    return ee

def hard_trimming(dict_fastq: dict, treshold=20):
    """
    Trim the sequences in a dictionary of FASTQ data based on a quality threshold.

    This function processes a given dictionary of FASTQ data and trims sequences
    along with their associated quality values and ASCII-encoded quality scores
    where the quality drops below the specified threshold. It iterates through
    each key in the dictionary, finds the first position where the quality score
    exceeds the threshold, and updates the respective dictionary entries with the
    trimmed sequence and quality values.

    :param dict_fastq: A dictionary representing FASTQ formatted data, where each
        key corresponds to a sequence identifier, and the associated value is
        another dictionary containing the sequence (`seq`), quality scores
        (`qual`), and ASCII-encoded quality scores (`ASCII_qual`).
    :type dict_fastq: dict
    :param treshold: An optional integer threshold for quality-based trimming.
        Values are capped below this threshold. Defaults to 20.
    :type treshold: int, optional
    :return: The updated dictionary where sequences and their quality values have
        been trimmed based on the provided threshold.
    :rtype: dict
    """
    for key in dict_fastq.keys():
        for value in range(len(dict_fastq[key]["qual"])):
            if dict_fastq[key]["qual"][value] > treshold:
                dict_fastq[key].update({"seq": dict_fastq[key]["seq"][value:]})
                dict_fastq[key].update({"qual": dict_fastq[key]["qual"][value:]})
                dict_fastq[key].update({"ASCII_qual": dict_fastq[key]["ASCII_qual"][value:]})
                #print(f"ho aggiornato i valori associati alla chiave {key}")
                break
    return dict_fastq

def dinamic_trimming(dict_fastq: dict, treshold=25, window=15):
    """
    Performs dynamic trimming of sequencing reads based on quality scores.

    This function takes a dictionary containing sequencing reads and their quality
    information. It performs a dynamic trimming process by evaluating the average
    quality score of a sliding window. When the average quality falls below a given
    threshold, the function trims the read from the point where quality criteria
    are no longer met.

    :param dict_fastq: Dictionary containing sequencing reads and their associated
        quality scores. Expected structure:
        {'read_id': {'qual': List[int], 'seq': str, 'ASCII_qual': str}}.
    :param treshold: Integer threshold below which the average quality score is
        considered too low. Default is 25.
    :param window: Integer size of the sliding window used to compute the average
        quality score. Default is 15.
    :return: The updated dictionary after processing, where reads not meeting
        quality criteria are trimmed.
    :rtype: dict
    """
    for key in dict_fastq.keys():
        quality = dict_fastq[key]["qual"]
        list_mean = quality[:window]
        if sum(list_mean)/len(list_mean) < treshold:
            for value in range(len(list_mean), len(quality)):
                if (sum(list_mean)+quality[value])/(len(list_mean)+1) < treshold:
                    list_mean.append(quality[value])
                else:
                    break
            dict_fastq[key].update({"seq": dict_fastq[key]["seq"][len(list_mean):]})
            dict_fastq[key].update({"qual": dict_fastq[key]["qual"][len(list_mean):]})
            dict_fastq[key].update({"ASCII_qual": dict_fastq[key]["ASCII_qual"][len(list_mean):]})
    return dict_fastq

def dict_filter(_dict_fastq):
    """
    Filters a dictionary of FASTQ data by removing entries with an expected error
    rate greater than 3. The function iterates through the keys of the dictionary,
    evaluating the "qual" attribute of each entry to calculate the expected error rate.

    :param _dict_fastq: Dictionary containing FASTQ data where each key corresponds
        to an entry and its associated "qual" values.
    :type _dict_fastq: dict
    :return: Filtered dictionary with only entries that have an expected error rate of 3 or less.
    :rtype: dict
    """
    list_keys = list(_dict_fastq.keys())
    for key in list_keys:
        expect_err = exp_err(_dict_fastq[key]["qual"])
        if expect_err > 3:
            del _dict_fastq[key]
    return _dict_fastq


file_f= t.extract_info(r"PhoeVulATCC8482_R1.fq.gz")
dict_fastq_f= parse_fastq(file_f)
keys = list(dict_fastq_f.keys())[:10]
# for acc in keys:
#     print(dict_fastq_f[acc]["seq"], len (dict_fastq_f[acc]["seq"]))
#     print(dict_fastq_f[acc]["qual"])
dict_filtered_f = dinamic_trimming(dict_fastq_f)
# for acc in keys:
#     print(dict_filtered_f[acc]["seq"], len (dict_filtered_f[acc]["seq"]))
#     print(dict_filtered_f[acc]["qual"])
seq_filtered_f = [dict_filtered_f[key]["seq"] for key in dict_filtered_f.keys() if len(dict_filtered_f[key]["seq"]) > 100]


file_r= t.extract_info(r"PhoeVulATCC8482_R2.fq.gz")
dict_fastq_r= parse_fastq(file_r)
keys_r = list(dict_fastq_r.keys())[:10]
# for acc in keys_r:
#     print(dict_fastq_r[acc]["seq"], len (dict_fastq_r[acc]["seq"]))
#     print(dict_fastq_r[acc]["qual"])
dict_filtered_r = dinamic_trimming(dict_fastq_r)
# for acc in keys_r:
#     print(dict_filtered_r[acc]["seq"], len (dict_filtered_r[acc]["seq"]))
#     print(dict_filtered_r[acc]["qual"])
seq_filtered_r = [dict_filtered_r[key]["seq"] for key in dict_filtered_r.keys() if len(dict_filtered_r[key]["seq"]) > 100]
print(len(seq_filtered_r), len(seq_filtered_f))

mucchio_selvaggio = seq_filtered_f + seq_filtered_r



def rev_comp(seqlist):
    """
    Generate the reverse complement sequences for a given list of DNA sequences, append them to the
    original list, and return the combined list.

    The function takes a list of DNA sequences (`seqlist`) as input, computes the reverse complements
    for each sequence in the list, and appends these reversed complements to the original sequence list.
    The combined list is then returned as output.

    :param seqlist: A list of DNA sequences for which reverse complements are to be calculated
    :type seqlist: list[str]
    :return: A combined list of original sequences and their reverse complements
    :rtype: list[str]
    """
    table= str.maketrans('ACTG','TGAC')
    total_list = [seq.translate(table)[::-1] for seq in seqlist] + seqlist
    return total_list


# def read_reads(fname):
#     """ FUnzione di prova che genera una lista di sequenza e prende in input un file FASTA (per ora) """
#     f = open(fname, 'r')
#     lines = f.readlines()
#     f.close()
#     reads = []

#     for line in lines:
#         if line[0] != '>':
#             reads = reads + [line.rstrip()]

#     return reads

# def parser_fastq(filename):
#     from Bio import SeqIO
#     import gzip
#     with gzip.open(filename, "rt") as file:
#         listaseq= [str(seq_record.seq) for seq_record in SeqIO.parse(file,"fastq")]
#     return listaseq

# def construct_graph(reads, k):
#     """Costruisco il grafo di De Bruijn da set di letture di lunghezza k, contando le ripetizioni dei nodi """
#     edges = []
#     nodes = set()
#
#     for read in reads:
#         for i in range(len(read) - k + 1):
#             edges.append(Edge((read[i:i + k - 1], read[i + 1:i + k])))
#             n1 = Node(read[i:i + k - 1])
#             n2 = Node(read[i + 1:i + k])
#
#             for node in nodes:
#                 if node == n1:
#                     node.incrementa_contatore()
#                     break
#             else:
#                 nodes.add(n1)
#
#             for node in nodes:
#                 if node == n2:
#                     node.incrementa_contatore()
#                     break
#             else:
#                 nodes.add(n2)
#
#     return edges, nodes

def construct_graph(reads, k):
    """
    Constructs a De Bruijn graph from a given list of DNA reads and k-mer length.

    The function builds a De Bruijn graph by analyzing k-mers in the reads. It
    creates nodes and edges based on overlapping k-mers, with edges connecting
    nodes derived from overlapping regions. The resulting graph structure can
    be used for sequence assembly or other bioinformatics analyses.

    :param reads: A list of DNA sequences (reads) from which the De Bruijn graph
        will be constructed.
    :type reads: list[str]
    :param k: An integer representing the k-mer length to be used in constructing
        the graph.
    :type k: int

    :return: A tuple where the first element is a dictionary of edges labeled by
        the sequence and connecting nodes, and the second element is a dictionary
        of nodes labeled by their sequence label.
    :rtype: tuple[dict[str, Edge], dict[str, Node]]
    """
    edges = {}
    nodes = {}

    for read in reads:
        for i in range(len(read) - k + 1):
            # Creazione e gestione degli archi
            edge_label = read[i:i + k - 1] + read[i + 1:i + k][-1]
            if edge_label not in edges:
                edges[edge_label] = Edge((read[i:i + k - 1], read[i + 1:i + k]))

            # Gestione dei nodi con dizionari
            n1_label = read[i:i + k - 1]
            n2_label = read[i + 1:i + k]

            if n1_label not in nodes:
                nodes[n1_label] = Node(n1_label)
            else:
                nodes[n1_label].incrementa_contatore()

            if n2_label not in nodes:
                nodes[n2_label] = Node(n2_label)
            else:
                nodes[n2_label].incrementa_contatore()

    return edges, nodes

def output_contigs(g):
    """
    Generate a contig from a given graph structure.

    This function processes a graph represented by its edges and nodes to construct
    a contig. It starts with the appropriate starting node, which is identified
    based on outgoing and incoming edges' existence, then iteratively follows the
    edges to build the contig sequence. The function raises an exception if the
    graph structure is invalid, such as missing a valid starting node or containing
    conflicting connections.

    :param g: A tuple containing the graph representation in two components:
        - `edges`: A collection of graph edges, where each edge connects nodes.
        - `nodes`: A mapping of node identifiers to their respective node objects
          with associated attributes.

    :return: A string representing the reconstructed contig constructed from
        traversing the graph based on its edges and nodes.
    :rtype: str
    :raises ValueError: If the graph structure is invalid, such as if no starting
        node is found or valid traversal cannot be completed because of invalid edges
        or nodes.

    """
    edges, nodes = g
    start = None
    for node in nodes.values():
        outcoming_edges = [edge for edge in edges.values() if
                           edge.label.startswith(node.label)]  # trovo i possibili archi per partono dal nodo corrente
        incoming_edges = [edge for edge in edges.values() if
                          edge.label.endswith(node.label)]  # trovo i possibili archi per arrivano nel nodo corrente

        # il nodo di partenza è quello che ha almeno un arco in uscita, ma nessun arco in ingresso
        if outcoming_edges and not incoming_edges:
            start = node
            break

    if start is None:
        raise ValueError("Nessun nodo di partenza trovato. Verifica la struttura del grafo.")

    contig = start.label
    current = start

    while True:
        outcoming_edges = [edge for edge in edges if
                           edge.label.startswith(current.label)]  # trovo gli archi che partono dal nodo corrente

        if len(outcoming_edges) == 0:
            break  # se non ci sono più archi esce dal ciclo
        elif len(outcoming_edges) == 1:
            next_edge = outcoming_edges[0]
        else:  # se ci sono più archi, scegli quello il cui nodo di arrivo abbia il contatore maggiore
            best_edge = None
            max_contatore = -1

            for edge in outcoming_edges:
                destination_label = edge.label[1:]
                # trova il nodo di destinazione per l'arco sulla base della label identificata
                destination_node = None
                for node in nodes.values():
                    if node.label == destination_label:
                        destination_node = node
                        break
                if destination_node.contatore > max_contatore:
                    best_edge = edge
                    max_contatore = destination_node.contatore

            if best_edge is None:
                raise ValueError("Nessun arco valido trovato con un nodo di destinazione valido.")

            next_edge = best_edge

        edges.remove(next_edge)  # rimuovi l'arco dalla lista degli archi
        contig += next_edge.label[-1]  # aggiungi l'ultimo carattere del k-mer al contig

        destination_label = next_edge.label[1:]  # definisco il nodo successivo per ricostruire il contig
        current = None
        for node in nodes.values():
            if node.label == destination_label:
                current = node
                break

        if current is None:
            raise ValueError(f"Errore: il nodo successivo con label {destination_label} non è stato trovato nel grafo.")

    return contig

#print(len(seq_filtered_f), len(seq_filtered_r), len(mucchio_selvaggio)) # mucchio_selvaggio = seq_filtered_f + seq_filtered_r
#print(len(rev_comp(mucchio_selvaggio)))
#prova = construct_graph(rev_comp(mucchio_selvaggio), 23)
#contig = output_contigs(prova)
#print(contig)